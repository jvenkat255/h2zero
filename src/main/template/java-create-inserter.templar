{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		PACKAGE DECLARATION, IMPORT STATEMENTS AND CLASS DEFINITION

		NOTES:
		  If the table is a constant - then this file will not be generated
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

package {database.package}.inserter;{\n}{\n}
// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}
//                (java-create-inserter.templar){\n}{\n}

import java.io.InputStream;{\n}
import java.sql.Connection;{\n}
import java.sql.PreparedStatement;{\n}
import java.sql.SQLException;{\n}
import java.sql.Timestamp;{\n}
import java.sql.Types;{\n}
import java.sql.Date;{\n}
import java.sql.Blob;{\n}
import java.sql.Clob;{\n}
{\n}
import synapticloop.h2zero.base.manager.ConnectionManager;{\n}

import {database.package}.model.util.Constants;{\n}
{\n}

{if options.metrics}
import synapticloop.h2zero.base.manager.MetricsManager;{\n}
import static {database.package}.metrics.{table.javaClassName}Metrics.*;{\n}
{\n}{\n}
{endif}

public class {table.javaClassName}Inserter {{{\n}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE INSERTER STRINGS FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{set table as baseSchemaObject}
{import classpath:/snippet/global/java-binder-declaration.templar}

{\t}// static fields generated by synapticloop h20{\n}
{\t}private static final String SQL_BUILTIN_INSERT_ALL = "insert into {table.name}(

	{loop table.fields as field}
		{field.name}{if !fieldStatus.last}, {endif}
	{endloop}
)";{\n}

{\t}private static final String SQL_BUILTIN_INSERT_VALUES = SQL_BUILTIN_INSERT_ALL + " values (
	{loop table.fields as field}
		?{if !fieldStatus.last}, {endif}
	{endloop}
)";{\n}

{\t}// static inserter SQL generated from the user input{\n}
{loop table.inserters as inserter}
{-- now for the insert clause --}
	{\t}private static final String SQL_{inserter.staticName} = 
	{if inserter.hasInsertClause}
		"{inserter.insertClause} " 
	{else}
		SQL_BUILTIN_INSERT_ALL 
	{endif}

	{if inserter.hasValuesClause}
		+ "{inserter.valuesClause} "
	{else}
		{if inserter.hasSelectClause}
			+ "{inserter.selectClause} "
		{endif}
		{if inserter.hasWhereClause}
			+ "{inserter.whereClause} "
		{endif}
	{endif};{\n}
{endloop}
{\n}


{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				INSERTER WITH DEFAULT VALUES
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{\t}public static int insert(Connection connection, {loop table.fields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}) throws SQLException {{{\n}

		{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_VALUES);{\n}

		{loop table.fields as field}
			{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
		{endloop}

		{\t}{\t}return(preparedStatement.executeUpdate());{\n}

{\t}}{\n}{\n}

{\t}public static int insertSilent({loop table.fields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}) {{{\n}

		{\t}{\t}int numResults = 0;{\n}

		{\t}{\t}Connection connection = null;{\n}

		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
		{\t}{\t}{\t}numResults = insert(connection, {loop table.fields as field}
			{field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop});{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}sqlex.printStackTrace();{\n}
		{\t}{\t}{\t}return(-1);{\n}
		{\t}{\t}} finally {{{\n}
		{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
		{\t}{\t}}{\n}
		{\t}{\t}return(numResults);{\n}

{\t}}{\n}{\n}

{--
  Now for the fields which have clobs or blobs
}
{if table.hasLargeObject}
	{\t}public static int insert(Connection connection, {loop table.fields as field}
				{if field.isLargeObject}
					InputStream {field.javaName}
				{else}
					{field.javaType} {field.javaName}
				{endif}
				{if fieldStatus.last}{else}, {endif}
			{endloop}) throws SQLException {{{\n}

			{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_VALUES);{\n}

			{loop table.fields as field}
				{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
			{endloop}

			{\t}{\t}return(preparedStatement.executeUpdate());{\n}

	{\t}}{\n}{\n}

	{\t}public static int insertSilent({loop table.fields as field}
				{if field.isLargeObject}
					InputStream {field.javaName}
				{else}
					{field.javaType} {field.javaName}
				{endif}
				{if fieldStatus.last}{else}, {endif}
			{endloop}) {{{\n}

			{\t}{\t}int numResults = 0;{\n}

			{\t}{\t}Connection connection = null;{\n}

			{\t}{\t}try {{{\n}
			{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
			{\t}{\t}{\t}numResults = insert(connection, {loop table.fields as field}
				{field.javaName}
				{if fieldStatus.last}{else}, {endif}
			{endloop});{\n}
			{\t}{\t}} catch (SQLException sqlex) {{{\n}
			{\t}{\t}{\t}sqlex.printStackTrace();{\n}
			{\t}{\t}{\t}return(-1);{\n}
			{\t}{\t}} finally {{{\n}
			{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
			{\t}{\t}}{\n}
			{\t}{\t}return(numResults);{\n}

	{\t}}{\n}{\n}
{endif}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				NOW FOR THE CUSTOM DESIGNED INSERTERS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{loop table.inserters as inserter}
	{\t}public static int {inserter.name}(Connection connection
			{loop inserter.allUniqueFields as field}
				, {field.javaType} {field.javaName}
			{endloop}
			) throws SQLException {{{\n}
		{\t}{\t}int numResults = 0;{\n}
		{\t}{\t}PreparedStatement preparedStatement = null;{\n}
			{if inserter.hasInsertClause}
				{\t}{\t}preparedStatement = connection.prepareStatement(SQL_{inserter.staticName});{\n}
			{else}
				{\t}{\t}preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_ALL);{\n}
			{endif}
			{loop inserter.allFields as field}
				{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
			{endloop}
			{\t}{\t}numResults = preparedStatement.executeUpdate();{\n}
			{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}

		{\t}{\t}{\n}
		{\t}{\t}return(numResults);{\n}
	{\t}}{\n}{\n}

	{\t}public static int {inserter.name}Silent(
			{loop inserter.allUniqueFields as field}
				{field.javaType} {field.javaName}
				{if !fieldStatus.last}, {endif}
			{endloop}
			) {{{\n}
		{\t}{\t}int numResults = 0;{\n}
		{\t}{\t}Connection connection = null;{\n}
		{\t}{\t}try {{{\n}
		{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
		{\t}{\t}{\t}numResults = {inserter.name}(connection
			{loop inserter.allUniqueFields as field}
				, {field.javaName}
			{endloop}
		);{\n}
		{\t}{\t}} catch (SQLException sqlex) {{{\n}
		{\t}{\t}{\t}sqlex.printStackTrace();{\n}
		{\t}{\t}{\t}return(-1);{\n}
		{\t}{\t}} finally {{{\n}
		{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
		{\t}{\t}}{\n}

		{\t}{\t}{\n}
		{\t}{\t}return(numResults);{\n}
	{\t}}{\n}

	{--
	  Now for the fields which have clobs or blobs
	}
	{if table.hasLargeObject}

		{\t}public static int {inserter.name}(Connection connection
				{loop inserter.allUniqueFields as field}
					{if field.isLargeObject}
						, InputStream {field.javaName}
					{else}
						, {field.javaType} {field.javaName}
					{endif}
				{endloop}
				) throws SQLException {{{\n}
			{\t}{\t}int numResults = 0;{\n}
			{\t}{\t}PreparedStatement preparedStatement = null;{\n}
				{if inserter.hasInsertClause}
					{\t}{\t}preparedStatement = connection.prepareStatement(SQL_{inserter.staticName});{\n}
				{else}
					{\t}{\t}preparedStatement = connection.prepareStatement(SQL_BUILTIN_INSERT_ALL);{\n}
				{endif}
				{loop inserter.allFields as field}
					{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
				{endloop}
				{\t}{\t}numResults = preparedStatement.executeUpdate();{\n}
				{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}

			{\t}{\t}{\n}
			{\t}{\t}return(numResults);{\n}
		{\t}}{\n}{\n}

		{\t}public static int {inserter.name}Silent(
				{loop inserter.allUniqueFields as field}
					{if field.isLargeObject}
						InputStream {field.javaName}
					{else}
						{field.javaType} {field.javaName}
					{endif}
					{if !fieldStatus.last}, {endif}
				{endloop}
				) {{{\n}
			{\t}{\t}int numResults = 0;{\n}
			{\t}{\t}Connection connection = null;{\n}
			{\t}{\t}try {{{\n}
			{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
			{\t}{\t}{\t}numResults = {inserter.name}(connection
				{loop inserter.allUniqueFields as field}
					, {field.javaName}
				{endloop}
			);{\n}
			{\t}{\t}} catch (SQLException sqlex) {{{\n}
			{\t}{\t}{\t}sqlex.printStackTrace();{\n}
			{\t}{\t}{\t}return(-1);{\n}
			{\t}{\t}} finally {{{\n}
			{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
			{\t}{\t}}{\n}

			{\t}{\t}{\n}
			{\t}{\t}return(numResults);{\n}
		{\t}}{\n}
	{endif}
{endloop}

}