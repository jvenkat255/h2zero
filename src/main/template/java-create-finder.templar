{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		PACKAGE DECLARATION, IMPORT STATEMENTS AND CLASS DEFINITION
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

package {database.package}.finder;{\n}{\n}
// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}
//                (java-create-finder.templar){\n}{\n}

{import classpath:/snippet/global/finder-imports.templar}

{if options.metrics}
import synapticloop.h2zero.base.manager.MetricsManager;{\n}
import static {database.package}.metrics.{table.javaClassName}Metrics.*;{\n}
{\n}{\n}
{endif}

public class {table.javaClassName}Finder {{{\n}
{set table as baseSchemaObject}
{import classpath:/snippet/global/java-binder-declaration.templar}

{set "Finder" as classType}
{import classpath:/snippet/global/java-logger-declaration.templar}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				FIRST UP THE FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{\t}private static final String SQL_SELECT_START = "select 
{loop table.fields as field}
	{field.name}
	{if !fieldStatus.last}, {endif}
{endloop}
 from {table.name}";{\n}


{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE FINDER FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}


{loop table.fields as field}
	{if field.primary}
		{set field.name as primaryFieldName}
		{set field.javaName as primaryFieldJavaName}
	{endif}
{endloop}

{\t}private static final String SQL_BUILTIN_FIND_BY_PRIMARY_KEY = SQL_SELECT_START + " where {primaryFieldName} = ?";{\n}
{\n}


{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE FINDERS FOR THE SELECT CLAUSES AND NORMAL CLAUSES
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{loop table.finders as finder}
	{if fn:null[finder.selectClause]}
		{\t}private static final String SQL_{finder.staticName} = SQL_SELECT_START
	{else}
		{\t}private static final String SQL_{finder.staticName} = "{finder.selectClause}"
	{endif}

	{if fn:notNull[finder.whereClause]} + " {finder.whereClause}"{endif}
	{if fn:notNull[finder.orderBy]} + " order by {finder.orderBy}"{endif};{\n}
{endloop}
{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE FINDERS FOR THE SELECT CLAUSES CACHES
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{set "true" as hasInfield}
{loop table.finders as finder}
	{if finder.hasInFields}
		{if fn:=[hasInfield, "true"]}
			{\t}// This is the cache for 'in finders' which have an ellipses (...) in the statement{\n}
			{set "false" as hasInfield}
		{endif}

		{\t}private static LruCache<String, String> {finder.name}_statement_cache = new LruCache<String, String>({finder.statementCacheSize});{\n}
	{endif}
{endloop}

		{\t}// now for the statement limit cache(s){\n}
		{\t}private static LruCache<String, String> findAll_limit_statement_cache = new LruCache<String, String>({table.findAllStatementCacheSize});{\n}

{loop table.finders as finder}
	{-- if fn:null[finder.selectClause]}
		{\t}private static LruCache<String, String> {finder.name}_limit_statement_cache = new LruCache<String, String>({finder.statementCacheSize});{\n}
	{-- endif}
{endloop}

{\n}{\t}private {table.javaClassName}Finder() {{}{\n}{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				FIND BY PRIMARY KEY
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{\t}/**{\n}
{\t} * Find a {table.javaClassName} by its primary key{\n}
{\t} * {\n}
{\t} * @param connection the connection item{\n}
{\t} * @param {primaryFieldJavaName} the primary key{\n}
{\t} * {\n}
{\t} * @return the unique result or throw an exception if one couldn't be found{\n}
{\t} * {\n}
{\t} * @throws H2ZeroFinderException if one couldn't be found{\n}
{\t} */{\n}

{\t}public static {table.javaClassName} findByPrimaryKey(Connection connection, Long {primaryFieldJavaName}) throws H2ZeroFinderException {{{\n}

			{if options.metrics}
{\t}{\t}{table.javaFieldName}FinderAccess.inc();{\n}
			{endif}

{\t}{\t}{table.javaClassName} {table.javaFieldName} = null;{\n}
{\t}{\t}PreparedStatement preparedStatement = null;{\n}
{\t}{\t}ResultSet resultSet = null;{\n}
{\n}
{\t}{\t}if(null == {primaryFieldJavaName}) {{{\n}
{\t}{\t}{\t}throw new H2ZeroFinderException("Could not find result as the primary key field [{primaryFieldJavaName}] was null.");{\n}
{\t}{\t}}{\n}
{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}preparedStatement = connection.prepareStatement(SQL_BUILTIN_FIND_BY_PRIMARY_KEY);{\n}
{\t}{\t}{\t}preparedStatement.setLong(1, {primaryFieldJavaName});{\n}
{\t}{\t}{\t}resultSet = preparedStatement.executeQuery();{\n}
{\t}{\t}{\t}{table.javaFieldName} = uniqueResult(resultSet);{\n}
{\t}{\t}} catch (SQLException sqlex) {{{\n}
{\t}{\t}{\t}throw new H2ZeroFinderException(sqlex);{\n}
{\t}{\t}} catch (H2ZeroFinderException h2zfex) {{{\n}
{\t}{\t}{\t}throw new H2ZeroFinderException(h2zfex.getMessage() + "  Additionally, the parameters were [{primaryFieldJavaName}:" + {primaryFieldJavaName} + "].");{\n}
{\t}{\t}} finally {{{\n}
{\t}{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement);{\n}
{\t}{\t}}{\n}
{\n}
{\t}{\t}if(null == {table.javaFieldName}) {{{\n}
{\t}{\t}{\t}throw new H2ZeroFinderException("Could not find result the parameters were [{primaryFieldJavaName}:" + {primaryFieldJavaName} + "].");{\n}
{\t}{\t}}{\n}
{\t}{\t}return({table.javaFieldName});{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Find a {table.javaClassName} by its primary key{\n}
{\t} * {\n}
{\t} * @param {primaryFieldJavaName} the primary key{\n}
{\t} * {\n}
{\t} * @return the unique result or throw an exception if one coudn't be found.{\n}
{\t} * {\n}
{\t} * @throws H2ZeroFinderException if one couldn't be found{\n}
{\t} */{\n}

{\t}public static {table.javaClassName} findByPrimaryKey(Long {primaryFieldJavaName}) throws H2ZeroFinderException {{{\n}
{\t}{\t}{table.javaClassName} {table.javaFieldName} = null;{\n}
{\t}{\t}Connection connection = null;{\n}
{\n}
{\t}{\t}if(null == {primaryFieldJavaName}) {{{\n}
{\t}{\t}{\t}throw new H2ZeroFinderException("Could not find result as the primary key field [{primaryFieldJavaName}] was null.");{\n}
{\t}{\t}}{\n}
{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
{\t}{\t}{\t}{table.javaFieldName} = findByPrimaryKey(connection, {primaryFieldJavaName});{\n}
{\t}{\t}} catch (SQLException sqlex) {{{\n}
{\t}{\t}{\t}throw new H2ZeroFinderException(sqlex);{\n}
{\t}{\t}} catch (H2ZeroFinderException h2zfex) {{{\n}
{\t}{\t}{\t}throw new H2ZeroFinderException(h2zfex.getMessage() + "  Additionally, the parameters were [{primaryFieldJavaName}:" + {primaryFieldJavaName} + "].");{\n}
{\t}{\t}} finally {{{\n}
{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
{\t}{\t}}{\n}
{\n}
{\t}{\t}if(null == {table.javaFieldName}) {{{\n}
{\t}{\t}{\t}throw new H2ZeroFinderException("Could not find result the parameters were [{primaryFieldJavaName}:" + {primaryFieldJavaName} + "].");{\n}
{\t}{\t}}{\n}
{\t}{\t}return({table.javaFieldName});{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Find a {table.javaClassName} by its primary key and silently fail.{\n}
{\t} * I.e. Do not throw an exception on error.{\n}
{\t} * {\n}
{\t} * @param connection the connection item{\n}
{\t} * @param {primaryFieldJavaName} the primary key{\n}
{\t} * {\n}
{\t} * @return the unique result or null if it couldn't be found{\n}
{\t} * {\n}
{\t} */{\n}

{\t}public static {table.javaClassName} findByPrimaryKeySilent(Connection connection, Long {primaryFieldJavaName}) {{{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}return(findByPrimaryKey(connection, {primaryFieldJavaName}));{\n}
{\t}{\t}} catch(H2ZeroFinderException h2zfex){{{\n}

{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.WARN)) {{{\n}
{\t}{\t}{\t}{\t}LOGGER.warn("H2ZeroFinderException findByPrimaryKeySilent(" + {primaryFieldJavaName} + "): " + h2zfex.getMessage());{\n}

{\t}{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.DEBUG)) {{{\n}
{\t}{\t}{\t}{\t}{\t}h2zfex.printStackTrace();{\n}
{\t}{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}return(null);{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Find a {table.javaClassName} by its primary key and silently fail.{\n}
{\t} * I.e. Do not throw an exception on error.{\n}
{\t} * {\n}
{\t} * @param {primaryFieldJavaName} the primary key{\n}
{\t} * {\n}
{\t} * @return the unique result or null if it couldn't be found{\n}
{\t} * {\n}
{\t} */{\n}

{\t}public static {table.javaClassName} findByPrimaryKeySilent(Long {primaryFieldJavaName}) {{{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}return(findByPrimaryKey({primaryFieldJavaName}));{\n}
{\t}{\t}} catch(H2ZeroFinderException h2zfex){{{\n}

{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.WARN)) {{{\n}
{\t}{\t}{\t}{\t}LOGGER.warn("H2ZeroFinderException findByPrimaryKeySilent(" + {primaryFieldJavaName} + "): " + h2zfex.getMessage());{\n}

{\t}{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.DEBUG)) {{{\n}
{\t}{\t}{\t}{\t}{\t}h2zfex.printStackTrace();{\n}
{\t}{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}return(null);{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				FIND ALL
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{\t}/**{\n}
{\t} * Find all UserTitle objects with the passed in connection, with limited{\n}
{\t} * results starting at a particular offset.{\n}
{\t} * {\n}
{\t} * If the limit parameter is null, there will be no limit applied.{\n}
{\t} * {\n}
{\t} * If the offset is null, then this will be set to 0{\n}
{\t} * {\n}
{\t} * If both limit and offset are null, then no limit and no offset will be applied{\n}
{\t} * to the statement.{\n}
{\t} * {\n}
{\t} * The passed in connection object is usable for transactional SQL statements,{\n}
{\t} * where the connection has already had a transaction started on it.{\n}
{\t} * {\n}
{\t} * If the connection object is null an new connection object will be created {\n}
{\t} * and closed at the end of the method.{\n}
{\t} * {\n}
{\t} * If the connection object is not null, then it will not be closed.{\n}
{\t} * {\n}
{\t} * @param connection - the connection object to use (or null if not part of a transaction){\n}
{\t} * @param limit - the limit for the result set{\n}
{\t} * @param offset - the offset for the start of the results.{\n}
{\t} * {\n}
{\t} * @return a list of all of the UserTitle objects{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the SQL statement{\n}
{\t} */{\n}

{\t}public static List<{table.javaClassName}> findAll(Connection connection, Integer limit, Integer offset) throws SQLException {{{\n}

			{if options.metrics}
{\t}{\t}{table.javaFieldName}FinderAccess.inc();{\n}
			{endif}

{\t}{\t}boolean hasConnection = (null != connection);{\n}
{\t}{\t}String statement = null;{\n}

{\t}{\t}// first find the statement that we want{\n}
{\n}
{\t}{\t}String cacheKey = limit + ":" + offset;{\n}
{\t}{\t}if(!findAll_limit_statement_cache.containsKey(cacheKey)) {{{\n}
{\t}{\t}{\t}// place the cacheKey in the cache for later use{\n}
{\n}
{\t}{\t}{\t}StringBuilder stringBuilder = new StringBuilder(SQL_SELECT_START);{\n}
{\n}
{\t}{\t}{\t}if(null != limit) {{{\n}
{\t}{\t}{\t}{\t}stringBuilder.append(" limit ");{\n}
{\t}{\t}{\t}{\t}stringBuilder.append(limit);{\n}
{\t}{\t}{\t}}{\n}
{\n}
{\t}{\t}{\t}if(null != offset) {{{\n}
{\t}{\t}{\t}{\t}stringBuilder.append(" offset ");{\n}
{\t}{\t}{\t}{\t}stringBuilder.append(offset);{\n}
{\t}{\t}{\t}}{\n}
{\n}
{\t}{\t}{\t}statement = stringBuilder.toString();{\n}
{\t}{\t}{\t}findAll_limit_statement_cache.put(cacheKey, statement);{\n}
{\t}{\t}} else {{{\n}
{\t}{\t}{\t}statement = findAll_limit_statement_cache.get(cacheKey);{\n}
{\t}{\t}}{\n}
{\n}

{\t}{\t}// now set up the statement{\n}
{\t}{\t}PreparedStatement preparedStatement = null;{\n}
{\t}{\t}ResultSet resultSet = null;{\n}
{\t}{\t}if(connection == null) {{{\n}
{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
{\t}{\t}}{\n}
{\n}

{\t}{\t}List<{table.javaClassName}> results = new ArrayList<{table.javaClassName}>();{\n}
{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}preparedStatement = connection.prepareStatement(statement);{\n}
{\t}{\t}{\t}resultSet = preparedStatement.executeQuery();{\n}
{\t}{\t}{\t}results = list(resultSet);{\n}
{\t}{\t}} catch(SQLException sqlex) {{{\n}
{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.WARN)) {{{\n}
{\t}{\t}{\t}{\t}LOGGER.warn("SQLException findAll(): " + sqlex.getMessage());{\n}

{\t}{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.DEBUG)) {{{\n}
{\t}{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
{\t}{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}}{\n}
{\t}{\t}{\t}throw sqlex;{\n}
{\t}{\t}} finally {{{\n}

{\t}{\t}{\t}if(hasConnection) {{{\n}
{\t}{\t}{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement, null);{\n}
{\t}{\t}{\t}} else {{{\n}
{\t}{\t}{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement, connection);{\n}
{\t}{\t}{\t}}{\n}

{\t}{\t}}{\n}
{\n}

{\t}{\t}return(results);{\n}
{\t}}{\n}
{\n}

{\t}public static List<{table.javaClassName}> findAll() throws SQLException {{{\n}
{\t}{\t}return(findAll(null, null, null));{\n}
{\t}}{\n}
{\n}

{\t}public static List<{table.javaClassName}> findAll(Connection connection) throws SQLException {{{\n}
{\t}{\t}return(findAll(connection, null, null));{\n}
{\t}}{\n}
{\n}

{\t}public static List<{table.javaClassName}> findAll(Integer limit, Integer offset) throws SQLException {{{\n}
{\t}{\t}return(findAll(null, limit, offset));{\n}
{\t}}{\n}
{\n}

{\t}public static List<{table.javaClassName}> findAllSilent() {{{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}return(findAll());{\n}
{\t}{\t}} catch(SQLException sqlex){{{\n}

{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.WARN)) {{{\n}
{\t}{\t}{\t}{\t}LOGGER.warn("SQLException findAllSilent(): " + sqlex.getMessage());{\n}

{\t}{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.DEBUG)) {{{\n}
{\t}{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
{\t}{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}return(new ArrayList<{table.javaClassName}>());{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{\t}public static List<{table.javaClassName}> findAllSilent(Integer limit, Integer offset) {{{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}return(findAll(limit, offset));{\n}
{\t}{\t}} catch(SQLException sqlex){{{\n}

{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.WARN)) {{{\n}
{\t}{\t}{\t}{\t}LOGGER.warn("SQLException findAllSilent(limit, offset): " + sqlex.getMessage());{\n}

{\t}{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.DEBUG)) {{{\n}
{\t}{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
{\t}{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}return(new ArrayList<{table.javaClassName}>());{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{\t}public static List<{table.javaClassName}> findAllSilent(Connection connection) {{{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}return(findAll(connection));{\n}
{\t}{\t}} catch(SQLException sqlex){{{\n}

{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.WARN)) {{{\n}
{\t}{\t}{\t}{\t}LOGGER.warn("SQLException findAllSilent(connection): " + sqlex.getMessage());{\n}

{\t}{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.DEBUG)) {{{\n}
{\t}{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
{\t}{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}return(new ArrayList<{table.javaClassName}>());{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{-- 

}

{\t}public static List<{table.javaClassName}> findAllSilent(Connection connection, Integer start, Integer offset) {{{\n}
{\t}{\t}try {{{\n}
{\t}{\t}{\t}return(findAll(connection, start, offset));{\n}
{\t}{\t}} catch(SQLException sqlex){{{\n}

{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.WARN)) {{{\n}
{\t}{\t}{\t}{\t}LOGGER.warn("SQLException findAllSilent(connection, limit, offset): " + sqlex.getMessage());{\n}

{\t}{\t}{\t}{\t}if(LOGGER.isEnabledFor(Level.DEBUG)) {{{\n}
{\t}{\t}{\t}{\t}{\t}sqlex.printStackTrace();{\n}
{\t}{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}}{\n}

{\t}{\t}{\t}return(new ArrayList<{table.javaClassName}>());{\n}
{\t}{\t}}{\n}
{\t}}{\n}
{\n}

{set table as tableOrView}
{import classpath:/snippet/finder/user-finders.templar}
{import classpath:/snippet/finder/user-finders-select-clause.templar}

}
