package {database.package}.model;{\n}{\n}

// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}
//                  (java-create-model.templar){\n}{\n}
{if !table.isConstant}
	import synapticloop.h2zero.base.manager.ConnectionManager;{\n}
	import synapticloop.h2zero.base.model.ModelBase;{\n}
	import synapticloop.h2zero.base.exception.H2ZeroPrimaryKeyException;{\n}
	import java.lang.StringBuilder;{\n}
	import java.sql.Connection;{\n}
	import java.sql.Date;{\n}
	import java.sql.Clob;{\n}
	import java.sql.Blob;{\n}
	import java.sql.ResultSet;{\n}
	import java.sql.Timestamp;{\n}
	import java.sql.Statement;{\n}
	import java.sql.PreparedStatement;{\n}
	import java.sql.SQLException;{\n}
	{\n}
{else}
	import java.util.HashMap;{\n}{\n}
{endif}

import {database.package}.model.util.Constants;{\n}

{if !table.isConstant}
	{\n}

	import {database.package}.finder.{table.javaClassName}Finder;{\n}
	{loop table.fields as field}
		{if fn:notNull[field.foreignKeyTable]}
			import {database.package}.finder.{field.foreignKeyTableLookup.javaClassName}Finder;{\n}
		{endif}
	{endloop}

{endif}

{\n}{\n}

{if options.metrics}
import synapticloop.h2zero.base.manager.MetricsManager;{\n}
import com.codahale.metrics.Counter;{\n}
import com.codahale.metrics.MetricRegistry;{\n}
import com.codahale.metrics.RatioGauge;{\n}

{\n}{\n}
{endif}

public class {table.javaClassName} {if !table.isConstant}extends ModelBase {endif}{{{\n}
{\t}// the binder is unused in code, but will generate compile problems if this {\n}
{\t}// class is no longer referenced in the h2zero file. Just a nicety for{\n}
{\t}// removing dead code{\n}
{\t}@SuppressWarnings("unused"){\n}
{\t}private static final String BINDER = Constants.{table.upperName}_binder;{\n}{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				CONSTANTS GENERATOR
}
{if table.isConstant}
	{loop table.constants as constant}
		{\t}public static final {table.javaClassName} {constant.name} = new {table.javaClassName}(
			{loop constant.values as value}
				{value}{if !valueStatus.last}, {endif}
			{endloop}
		);{\n}
	{endloop}
	{\n}
	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		Now add in the static array
	}

	{\t}public static {table.javaClassName}[] ALL =  {{{\n}
		{\t}{\t}{loop table.constants as constant}
				{table.javaClassName}.{constant.name}{if !constantStatus.last}, {endif}
			{endloop}{\n}
	{\t}};{\n}
	{\n}

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		And the static HashMap lookup
	}

	{\t}public static HashMap<Long, {table.javaClassName}> ALL_LOOKUP = new HashMap<Long, {table.javaClassName}>();{\n}
	{\t}static{{{\n}
		{loop table.constants as constant}
			{\t}{\t}ALL_LOOKUP.put({constant.primaryKeyValue}, {table.javaClassName}.{constant.name});{\n}
		{endloop}{\n}
	{\t}};{\n}
	{\n}

{endif}

	{loop table.fields as field}
		{if field.primary}
			{\t}public static final String PRIMARY_KEY_FIELD = "{field.name}";{\n}{\n}
		{endif}
	{endloop}

{if !table.isConstant}
	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					SQL insert
	}

	{\t}private static final String SQL_INSERT = "insert into {table.name} values (

	{-- now loop through all of the fields }
	{loop table.fields as field}
		?
		{if fieldStatus.last}{else}, {endif}

	{endloop})";{\n}

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					SQL update
	}

	{\t}private static final String SQL_UPDATE = "update {table.name} set 

	{-- now loop through all of the fields }
	{loop table.fields as field}
		{if field.primary}{else}
			{field.name} = ?
			{if fieldStatus.last}{else}, {endif}
		{endif}

	{endloop} where " + PRIMARY_KEY_FIELD + " = ?";{\n}

	{\t}private static final String SQL_DELETE = "delete from {table.name} where " + PRIMARY_KEY_FIELD + " = ?";{\n}

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					INSERT IF NOT EXISTS SQL - ENSURE
	}
	{\t}private static final String SQL_ENSURE = "select " + PRIMARY_KEY_FIELD + " from {table.name} where 
	{loop table.fields as field}
			{if !field.primary}
				{field.name} = ?
				{if !fieldStatus.last} and {endif}
			{endif}
		{endloop}";{\n}

	{\n}
	{\t}// whether the fields are auto-populated{\n}
	{\t}private boolean[] populated = {{ 
		{loop table.fields as field}{field.populate}{if fieldStatus.last}{else}, {endif}{endloop}
	 };{\n}{\n}
{endif}{-- end of !if.isConstant}

	{if options.metrics}
		{-- 
			NOW FOR THE METRICS
		}
		{\t}// These are the metrics holders - there are a lot of them - better to have and not need, than need and not have!{\n}
		{\t}// <fieldName>SetterHit counts the number setters that are invoked which successfully changes the value{\n}
		{\t}// <fieldName>SetterMiss counts the number of setters that did not change the value{\n}
		{\t}// <fieldName>SetterHitRatio provides the ratio of hits to total setters{\n}
		{\t}// <fieldName>SetterMissRatio provides the ratio of misses to total setters{\n}
		{\t}// <fieldName>GetterHit counts the number of getters that returns an already filled in value{\n}
		{\t}// <fieldName>GetterMiss counts the number of getters that needed to be loaded from a non-populated value{\n}
		{\t}// <fieldName>GetterHitRatio provides the ratio of hits to total getters{\n}
		{\t}// <fieldName>GetterMissRatio provides the ratio of misses to total getters{\n}
		{\t}// <className>GetterHit counts the number of getters that returns an already filled in object{\n}
		{\t}// <className>GetterMiss counts the number of getters that needed to be loaded from a non-populated object{\n}
		{\t}// <className>GetterHitRatio provides the ratio of hits to total getters{\n}
		{\t}// <className>GetterMissRatio provides the ratio of misses to total getters{\n}
		{loop table.fields as field}

			{if fn:notNull[field.foreignKeyTable]}
				{\t}private static final Counter {field.secondaryJavaName}GetterHit = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "{field.secondaryJavaName}", "getter", "hit"));{\n}
				{\t}private static final Counter {field.secondaryJavaName}GetterMiss = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "{field.secondaryJavaName}", "getter", "miss"));{\n}
				{\t}private static final RatioGauge {field.secondaryJavaName}GetterHitRatio = MetricsManager.getMetricsRegistry().register(MetricRegistry.name({table.javaClassName}.class, "{field.secondaryJavaName}", "getter", "hit", "ratio"), new RatioGauge() {{ 
					protected Ratio getRatio() {{ 
						return(Ratio.of({field.secondaryJavaName}GetterHit.getCount(), {field.secondaryJavaName}GetterHit.getCount() + {field.secondaryJavaName}GetterMiss.getCount()));
					}
				});{\n}
				{\t}private static final RatioGauge {field.secondaryJavaName}GetterMissRatio = MetricsManager.getMetricsRegistry().register(MetricRegistry.name({table.javaClassName}.class, "{field.secondaryJavaName}", "getter", "miss", "ratio"), new RatioGauge() {{ 
					protected Ratio getRatio() {{ 
						return(Ratio.of({field.secondaryJavaName}GetterMiss.getCount(), {field.secondaryJavaName}GetterHit.getCount() + {field.secondaryJavaName}GetterMiss.getCount()));
					}
				});{\n}
			{endif}

			{\t}private static final Counter {field.javaName}GetterHit = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "{field.javaName}", "getter", "hit"));{\n}
			{\t}private static final Counter {field.javaName}GetterMiss = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "{field.javaName}", "getter", "miss"));{\n}
			{\t}private static final RatioGauge {field.javaName}GetterHitRatio = MetricsManager.getMetricsRegistry().register(MetricRegistry.name({table.javaClassName}.class, "{field.javaName}", "getter", "hit", "ratio"), new RatioGauge() {{ 
				protected Ratio getRatio() {{ 
					return(Ratio.of({field.javaName}GetterHit.getCount(), {field.javaName}GetterHit.getCount() + {field.javaName}GetterMiss.getCount()));
				}
			});{\n}
			{\t}private static final RatioGauge {field.javaName}GetterMissRatio = MetricsManager.getMetricsRegistry().register(MetricRegistry.name({table.javaClassName}.class, "{field.javaName}", "getter", "miss", "ratio"), new RatioGauge() {{ 
				protected Ratio getRatio() {{ 
					return(Ratio.of({field.javaName}GetterMiss.getCount(), {field.javaName}GetterHit.getCount() + {field.javaName}GetterMiss.getCount()));
				}
			});{\n}

			{\t}private static final Counter {field.javaName}SetterHit = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "{field.javaName}", "setter", "hit"));{\n}
			{\t}private static final Counter {field.javaName}SetterMiss = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "{field.javaName}", "setter", "miss"));{\n}

			{\t}private static final RatioGauge {field.javaName}SetterHitRatio = MetricsManager.getMetricsRegistry().register(MetricRegistry.name({table.javaClassName}.class, "{field.javaName}", "Setter", "hit", "ratio"), new RatioGauge() {{ 
				protected Ratio getRatio() {{ 
					return(Ratio.of({field.javaName}SetterHit.getCount(), {field.javaName}SetterHit.getCount() + {field.javaName}SetterMiss.getCount()));
				}
			});{\n}
			{\t}private static final RatioGauge {field.javaName}SetterMissRatio = MetricsManager.getMetricsRegistry().register(MetricRegistry.name({table.javaClassName}.class, "{field.javaName}", "Setter", "miss", "ratio"), new RatioGauge() {{ 
				protected Ratio getRatio() {{ 
					return(Ratio.of({field.javaName}SetterMiss.getCount(), {field.javaName}SetterHit.getCount() + {field.javaName}SetterMiss.getCount()));
				}
			});{\n}

		{endloop}
		{\n}

		{\t}// now for the table statistics{\n}
		{\t}private static final Counter {table.javaFieldName}Insert = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "insert"));{\n}
		{\t}private static final Counter {table.javaFieldName}InsertOrUpdate = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "insertOrUpdate"));{\n}
		{\t}private static final Counter {table.javaFieldName}Delete = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "delete"));{\n}
		{\t}private static final Counter {table.javaFieldName}Ensure = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "ensure"));{\n}
		{\t}private static final Counter {table.javaFieldName}Refresh = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "refresh"));{\n}
		{\t}private static final Counter {table.javaFieldName}Update = MetricsManager.getMetricsRegistry().counter(MetricRegistry.name({table.javaClassName}.class, "update"));{\n}
		{\n}

	{endif}
	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					LIST ALL OF THE JAVA FIELDS
	}

	{loop table.fields as field}
		{if fn:notNull[field.foreignKeyTable]}
			{\t}private {field.foreignKeyTableLookup.javaClassName} {field.secondaryJavaName} = null;{\n}
		{endif}
		{if fieldStatus.last}
			{\n}
		{endif}
	{endloop}

	{loop table.fields as field}
		{\t}private {field.javaType} {field.javaName} = null;{\n}
	{endloop}
	{\n}


	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					CONSTRUCTORS
				what about null-able fields?
	}

	{\t}public {table.javaClassName}(
		{loop table.fields as field}
			{field.javaType} {field.javaName}
			{if fieldStatus.last}{else}, {endif}
		{endloop}
	) {{{\n}
		{loop table.fields as field}
			{\t}{\t}this.{field.javaName} = {field.javaName};{\n}
		{endloop}

	{\t}}{\n}

	{if table.hasNonNullConstructor}
	{\n}
		{\t}public {table.javaClassName}(
			{loop table.nonNullFields as field}
				{field.javaType} {field.javaName}
				{if fieldStatus.last}{else}, {endif}
			{endloop}
		) {{{\n}
			{loop table.fields as field}
				{if field.nullable}
					{\t}{\t}this.{field.javaName} = null;{\n}
				{else}
					{\t}{\t}this.{field.javaName} = {field.javaName};{\n}
				{endif}
			{endloop}

		{\t}}{\n}
	{endif}

{if !table.isConstant}
	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					PRIMARY KEY TEST AND SETTER/GETTER
	}

	{loop table.fields as field}
		{if field.primary}
			{\n}
			{\t}private boolean primaryKeySet() {{{\n}
			{\t}{\t}return(null != {field.javaName});{\n}
			{\t}}{\n}
			{\n}
		{endif}
	{endloop}{\n}

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				C(R)UD METHODS - WITHOUT THE READ
	}

	{\t}public void insert(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {{{\n}
	{if options.metrics}
		{\t}{\t}{table.javaFieldName}Insert.inc();{\n}
	{endif}

	{\t}{\t}if(primaryKeySet()) {{{\n}
	{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Cannot insert bean when primary key is not null.");{\n}
	{\t}{\t}}{\n}
	{\t}{\t}// create this bean {\n}
	{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_INSERT, Statement.RETURN_GENERATED_KEYS);{\n}

	{loop table.fields as field}
		{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
	{endloop}

	{\t}{\t}preparedStatement.executeUpdate();{\n}

	{\t}{\t}ResultSet resultSet = preparedStatement.getGeneratedKeys();{\n}
	{\t}{\t}if(resultSet.next()) {{{\n}

	{loop table.fields as field}
		{if field.primary}
			{\t}{\t}{\t}this.{field.javaName} = resultSet.getLong(1);{\n}
		{endif}
	{endloop}

	{\t}{\t}} else {{{\n}
	{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Could not get return value for primary key!");{\n}
	{\t}{\t}}{\n}


	{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement);{\n}

	{\t}}{\n}
	{\n}

	{\t}public void insertSilent(Connection connection) {{{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}insert(connection);{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}public void insert() throws SQLException, H2ZeroPrimaryKeyException {{{\n}
	{\t}{\t}Connection connection = null;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}insert(connection);{\n}
	{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}if(connection != null) {{{\n}
	{\t}{\t}{\t}{\t}try {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}{\t}{\t}// do nothing{\n}
	{\t}{\t}{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection = null;{\n}
	{\t}{\t}{\t}{\t}}{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}


	{\t}public void insertSilent() {{{\n}
	{\t}{\t}Connection connection = null;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}insert(connection);{\n}
	{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}if(connection != null) {{{\n}
	{\t}{\t}{\t}{\t}try {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}{\t}{\t}// do nothing{\n}
	{\t}{\t}{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection = null;{\n}
	{\t}{\t}{\t}{\t}}{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{--
	    ENSURE
	}
	{\t}public void ensure(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {{{\n}

	{if options.metrics}
		{\t}{\t}{table.javaFieldName}Ensure.inc();{\n}
	{endif}

	{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_ENSURE);{\n}

	{loop table.nonPrimaryFields as field}
		{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.index}, {field.javaName});{\n}
	{endloop}

	{\t}{\t}ResultSet resultSet = preparedStatement.executeQuery();{\n}

	{\t}{\t}if(resultSet.next()) {{{\n}

	{loop table.fields as field}
		{if field.primary}
			{\t}{\t}{\t}this.{field.javaName} = resultSet.getLong(1);{\n}
		{endif}
	{endloop}

	{\t}{\t}} else {{{\n}
	{\t}{\t}{\t}// could not find the value - need to insert it - null is the primary key{\n}
	{\t}{\t}{\t}insert(connection);{\n}
	{\t}{\t}}{\n}


	{\t}{\t}ConnectionManager.closeAll(resultSet, preparedStatement);{\n}

	{\t}}{\n}
	{\n}

	{\t}public void ensureSilent(Connection connection) {{{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}ensure(connection);{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}public void ensure() throws SQLException, H2ZeroPrimaryKeyException {{{\n}
	{\t}{\t}Connection connection = null;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}ensure(connection);{\n}
	{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}if(connection != null) {{{\n}
	{\t}{\t}{\t}{\t}try {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}{\t}{\t}// do nothing{\n}
	{\t}{\t}{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection = null;{\n}
	{\t}{\t}{\t}{\t}}{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}


	{\t}public void ensureSilent() {{{\n}
	{\t}{\t}Connection connection = null;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}ensure(connection);{\n}
	{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}if(connection != null) {{{\n}
	{\t}{\t}{\t}{\t}try {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}{\t}{\t}// do nothing{\n}
	{\t}{\t}{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection = null;{\n}
	{\t}{\t}{\t}{\t}}{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}public void update(Connection connection) throws SQLException, H2ZeroPrimaryKeyException {{{\n}

	{if options.metrics}
		{\t}{\t}{table.javaFieldName}Update.inc();{\n}
	{endif}

	{\t}{\t}if(!primaryKeySet()) {{{\n}
	{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Cannot update bean when primary key is null.");{\n}
	{\t}{\t}}{\n}

	{\t}{\t}if(isDirty) {{{\n}
	{\t}{\t}{\t}// update this bean, but only if dirty{\n}
	{\t}{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_UPDATE);{\n}

	{set fn:length[table.fields] as preparedStatementSize}

	{loop table.fields as field}
		{if !field.primary}
			{\t}{\t}{\t}ConnectionManager.set{field.upperType}(preparedStatement, {fieldStatus.offset}, {field.javaName});{\n}
		{endif}
	{endloop}

	{\t}{\t}{\t}// now set the primary key{\n}
	{loop table.fields as field}
		{if field.primary}
			{\t}{\t}{\t}preparedStatement.setLong({preparedStatementSize}, {field.javaName});{\n}
		{endif}
	{endloop}

	{\t}{\t}{\t}preparedStatement.executeUpdate();{\n}
	{\t}{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
	{\t}{\t}{\t}isDirty = false;{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}public void updateSilent(Connection connection) {{{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}update(connection);{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}public void update() throws SQLException, H2ZeroPrimaryKeyException {{{\n}
	{\t}{\t}Connection connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}update(connection);{\n}
	{\t}{\t}connection.close();{\n}
	{\t}}{\n}
	{\n}

	{\t}public void updateSilent() {{{\n}
	{\t}{\t}Connection connection = null;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}update(connection);{\n}
	{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}if(connection != null) {{{\n}
	{\t}{\t}{\t}{\t}try {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}{\t}{\t}// do nothing{\n}
	{\t}{\t}{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection = null;{\n}
	{\t}{\t}{\t}{\t}}{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}public void insertOrUpdate(Connection connection) throws H2ZeroPrimaryKeyException, SQLException {{{\n}

	{if options.metrics}
		{\t}{\t}{table.javaFieldName}InsertOrUpdate.inc();{\n}
	{endif}

	{\t}{\t}if(!primaryKeySet()) {{{\n}
	{\t}{\t}{\t}insert(connection);{\n}
	{\t}{\t}} else {{{\n}
	{\t}{\t}{\t}update(connection);{\n}
	{\t}{\t}}{\n}

	{\t}}{\n}
	{\n}


	{\t}public void insertOrUpdate() throws H2ZeroPrimaryKeyException, SQLException {{{\n}

	{\t}{\t}Connection connection = null;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}insertOrUpdate(connection);{\n}

	{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}throw(h2zpkex);{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}throw (sqlex);{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}if(connection != null) {{{\n}
	{\t}{\t}{\t}{\t}try {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}{\t}{\t}// do nothing{\n}
	{\t}{\t}{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection = null;{\n}
	{\t}{\t}{\t}{\t}}{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}
	{\t}public void insertOrUpdateSilent(Connection connection) {{{\n}

	{if options.metrics}
		{\t}{\t}{table.javaFieldName}InsertOrUpdate.inc();{\n}
	{endif}

	{\t}{\t}try {{{\n}

	{\t}{\t}{\t}if(!primaryKeySet()) {{{\n}
	{\t}{\t}{\t}{\t}insert(connection);{\n}
	{\t}{\t}{\t}} else {{{\n}
	{\t}{\t}{\t}{\t}update(connection);{\n}
	{\t}{\t}{\t}}{\n}

	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}public void insertOrUpdateSilent() {{{\n}

	{if options.metrics}
		{\t}{\t}{table.javaFieldName}InsertOrUpdate.inc();{\n}
	{endif}

	{\t}{\t}Connection connection = null;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}

	{\t}{\t}{\t}if(!primaryKeySet()) {{{\n}
	{\t}{\t}{\t}{\t}insert(connection);{\n}
	{\t}{\t}{\t}} else {{{\n}
	{\t}{\t}{\t}{\t}update(connection);{\n}
	{\t}{\t}{\t}}{\n}

	{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}if(connection != null) {{{\n}
	{\t}{\t}{\t}{\t}try {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}{\t}{\t}// do nothing{\n}
	{\t}{\t}{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection = null;{\n}
	{\t}{\t}{\t}{\t}}{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}public void delete(Connection connection) throws SQLException, H2ZeroPrimaryKeyException{{{\n}

	{if options.metrics}
		{\t}{\t}{table.javaFieldName}Delete.inc();{\n}
	{endif}

	{\t}{\t}if(!primaryKeySet()) {{{\n}
	{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Cannot delete bean when primary key is null.");{\n}
	{\t}{\t}}{\n}
	{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_DELETE);{\n}
	{loop table.fields as field}
		{if field.primary}
			{\t}{\t}preparedStatement.setLong(1, {field.javaName});{\n}
		{endif}
	{endloop}
	{\t}{\t}preparedStatement.executeUpdate();{\n}
	{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
	{\t}}{\n}
	{\n}

	{\t}public void deleteSilent(Connection connection) {{{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}delete(connection);{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}public void delete() throws SQLException, H2ZeroPrimaryKeyException {{{\n}
	{\t}{\t}Connection connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}delete(connection);{\n}
	{\t}{\t}connection.close();{\n}
	{\t}}{\n}
	{\n}

	{\t}public void deleteSilent() {{{\n}
	{\t}{\t}Connection connection = null;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}delete(connection);{\n}
	{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}} catch(SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}if(connection != null) {{{\n}
	{\t}{\t}{\t}{\t}try {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection.close();{\n}
	{\t}{\t}{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}{\t}{\t}// do nothing{\n}
	{\t}{\t}{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}{\t}{\t}connection = null;{\n}
	{\t}{\t}{\t}{\t}}{\n}
	{\t}{\t}{\t}}{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

	{\t}public void refresh() throws H2ZeroPrimaryKeyException {{{\n}
	{if options.metrics}
		{\t}{\t}{table.javaFieldName}Refresh.inc();{\n}
	{endif}
	{\t}{\t}if(!primaryKeySet()) {{{\n}
	{\t}{\t}{\t}throw new H2ZeroPrimaryKeyException("Cannot refresh bean when primary key is null.");{\n}
	{\t}{\t}}{\n}
	{loop table.fields as field}
		{if field.primary}
			{\t}{\t}{table.javaClassName} {table.javaFieldName} = {table.javaClassName}Finder.findByPrimaryKeySilent(this.{field.javaName});{\n}
		{endif}
	{endloop}

		{loop table.fields as field}
			{\t}{\t}this.{field.javaName} = {table.javaFieldName}.get{field.javaAccessorName}();{\n}
		{endloop}

	{\t}}{\n}
	{\n}


	{\t}public void refreshSilent() {{{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}refresh();{\n}
	{\t}{\t}} catch(H2ZeroPrimaryKeyException h2zpkex) {{{\n}
	{\t}{\t}{\t}h2zpkex.printStackTrace();{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}
	{\n}

{endif} {-- end of !isconstant table }

	{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					SETTERS AND GETTERS
	}

	{loop table.fields as field}
		{if fn:notNull[field.foreignKeyTable]}
			{\t}public {field.foreignKeyTableLookup.javaClassName} get{field.secondaryJavaFieldName}() {{{\n}
			{if !field.foreignKeyTableLookup.isConstant}
				{\t}{\t}if(null == this.{field.secondaryJavaName}) {{{\n}
				{if options.metrics}
					{\t}{\t}{\t}{field.secondaryJavaName}GetterMiss.inc();{\n}
				{endif}
				{\t}{\t}{\t}this.{field.secondaryJavaName} = {field.foreignKeyTableLookup.javaClassName}Finder.findByPrimaryKeySilent(this.{field.javaName});{\n}
				{if options.metrics}
					{\t}{\t}} else {{{\n}
					{\t}{\t}{\t}{field.secondaryJavaName}GetterHit.inc();{\n}
				{endif}
				{\t}{\t}}{\n}

				{\t}{\t}return(this.{field.secondaryJavaName});{\n}
			{else}
				{if options.metrics}
					{\t}{\t}{field.secondaryJavaName}GetterHit.inc();{\n}
				{endif}
				{\t}{\t}return({field.foreignKeyTableLookup.javaClassName}.ALL_LOOKUP.get(this.{field.javaName}));{\n}
			{endif}

			{--
				At this point the foreign table is constant so it was already looked up
				at construction time
			}
			{\t}}{\n}{\n}
		{endif}
	{endloop}

	{\t}/*{\n}
	{\t} * Boring ol' getters and setters {\n}
	{\t} */{\n}
	{\n}

	{loop table.fields as field}
		{\t}public {field.javaType} get{field.javaAccessorName}() {{ 

			{if options.metrics}
				{field.javaName}GetterHit.inc();
			{endif}

			return(this.{field.javaName}); 
		}{\n}

		{if !table.isConstant}
			{\t}public void set{field.javaAccessorName}({field.javaType} {field.javaName}) {{ 
				if(isDifferent(this.{field.javaName}, {field.javaName})) {{ 
					this.{field.javaName} = {field.javaName};
					this.isDirty = true; 

					{if fn:notNull[field.foreignKeyTable]}
						this.{field.secondaryJavaName} = null;
					{endif}

					{if options.metrics}
						{field.javaName}SetterHit.inc();
				} else {{
						{field.javaName}SetterMiss.inc();
					{endif}

				}
			}{\n}
		{endif}

	{endloop}
	{-- Now we need the toString Method--}
	{\n}
		{\t}public String toString() {{{\n}
		{\t}{\t}StringBuilder stringBuilder = new StringBuilder();{\n}

		{\t}{\t}stringBuilder.append("Model[{table.javaClassName}]\n");{\n}
		{loop table.fields as field}
			{if field.secure}
				{\t}{\t}stringBuilder.append("  Field[{field.javaName}:<secure>]\n");{\n}
			{else}
				{\t}{\t}stringBuilder.append("  Field[{field.javaName}:" + this.{field.javaName} + "]\n");{\n}
			{endif}
		{endloop}

		{\t}{\t}return(stringBuilder.toString());{\n}
		{\t}}{\n}


	{-- Now we need the toJsonString Method--}
	{\n}
		{\t}public String toJsonString() {{{\n}
		{\t}{\t}StringBuilder stringBuilder = new StringBuilder();{\n}

		{\t}{\t}stringBuilder.append("{{\n");{\n}
		{\t}{\t}stringBuilder.append("  \"model\": {{\n");{\n}
		{\t}{\t}stringBuilder.append("    \"name\": \"{table.javaClassName}\",\n");{\n}
		{\t}{\t}stringBuilder.append("    \"fields\": [\n");{\n}

		{loop table.fields as field}
			{if field.secure}
				{\t}{\t}stringBuilder.append("     {{ \"name\": \"{field.javaName}\", \"value\": \"<secure>\" }\n");{\n}
			{else}
				{\t}{\t}stringBuilder.append("     {{ \"name\": \"{field.javaName}\", \"value\": {if field.shouldEscape}\"{endif}" + this.{field.javaName} + "{if field.shouldEscape}\"{endif} }{if !fieldStatus.last}, {endif}\n");{\n}
			{endif}
		{endloop}

		{\t}{\t}stringBuilder.append("    ]\n");{\n}
		{\t}{\t}stringBuilder.append("  }\n");{\n}
		{\t}{\t}stringBuilder.append("}\n");{\n}

		{\t}{\t}return(stringBuilder.toString());{\n}
		{\t}}{\n}
		{\n}

	{-- and the getJSONString - for chaining --}
	{\t}public String getJsonString() {{{\n}
	{\t}{\t}return(toJsonString());{\n}
	{\t}}{\n}
}
