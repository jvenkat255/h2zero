{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
		PACKAGE DECLARATION, IMPORT STATEMENTS AND CLASS DEFINITION

		NOTES:
		  If the table is a constant - then this file will not be generated
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

package {database.package}.deleter;{\n}{\n}
// - - - - thoughtfully generated by synapticloop h2zero - - - - {\n}
//    with the use of synapticloop templar templating language{\n}
//                (java-create-deleter.templar){\n}{\n}
import java.sql.Connection;{\n}
import java.sql.PreparedStatement;{\n}
import java.sql.SQLException;{\n}
import java.sql.Types;{\n}
{\n}
import synapticloop.h2zero.base.manager.ConnectionManager;{\n}

import {database.package}.model.util.Constants;{\n}
{\n}

{if options.metrics}
import synapticloop.h2zero.base.manager.MetricsManager;{\n}
import static {database.package}.metrics.{table.javaClassName}Metrics.*;{\n}
{\n}{\n}
{endif}

public class {table.javaClassName}Deleter {{{\n}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE DELETER STRINGS FIELDS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{set table as baseSchemaObject}
{import classpath:/snippet/global/java-binder-declaration.templar}

{\t}// static fields generated by synapticloop h20{\n}
{\t}private static final String SQL_BUILTIN_DELETE_ALL = "delete from {table.name}";{\n}
{\t}private static final String SQL_BUILTIN_DELETE_ALL_TRUNCATE = "truncate table {table.name}";{\n}
{\t}private static final String SQL_DELETE_START = "delete from {table.name} ";{\n}
{loop table.fields as field}
	{if field.primary}
		{set field.name as primaryFieldName}
		{set field.javaName as primaryFieldJavaName}
	{endif}
{endloop}

{\t}private static final String SQL_BUILTIN_DELETE_BY_PRIMARY_KEY = SQL_DELETE_START + "where {primaryFieldName} = ?";{\n}{\n}

{loop table.deleters as deleter}
	{if deleterStatus.first}
		{\t}// static fields generated from the user input{\n}
	{endif}
	{\t}private static final String SQL_{deleter.staticName} = SQL_DELETE_START
	{if fn:notNull[deleter.whereClause]} + " {deleter.whereClause}"{endif};{\n}
{endloop}
{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				DELETE BY PRIMARY KEY
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{\t}/**{\n}
{\t} * Delete a row in the {table.upperName} table by its primary key{\n}
{\t} * {\n}
{\t} * @param connection The connection{\n}
{\t} * @param {primaryFieldJavaName} the primary key to delete{\n}
{\t} * @return the number of rows deleted{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the delete{\n}
{\t} */{\n}

{\t}public static int deleteByPrimaryKey(Connection connection, Long {primaryFieldJavaName}) throws SQLException {{{\n}
	{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_DELETE_BY_PRIMARY_KEY);{\n}
	{\t}{\t}preparedStatement.setLong(1, {primaryFieldJavaName});{\n}
	{\t}{\t}int numResults = preparedStatement.executeUpdate();{\n}
	{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
	{\t}{\t}return(numResults);{\n}
{\t}}{\n}{\n}

{\t}/**{\n}
{\t} * Delete a row in the {table.upperName} table by its primary key{\n}
{\t} * {\n}
{\t} * @param {primaryFieldJavaName} the primary key to delete{\n}
{\t} * @return the number of rows deleted{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the delete{\n}
{\t} */{\n}

{\t}public static int deleteByPrimaryKey(Long {primaryFieldJavaName}) throws SQLException {{{\n}
	{\t}{\t}Connection connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}int numResults = deleteByPrimaryKey(connection, {primaryFieldJavaName});{\n}
	{\t}{\t}ConnectionManager.closeAll(connection);{\n}
	{\t}{\t}return(numResults);{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Delete a row in the {table.upperName} table by its primary key silently{\n}
{\t} * (i.e. don't throw an exception if it coudn't be deleted).{\n}
{\t} * {\n}
{\t} * @param {primaryFieldJavaName} the primary key to delete{\n}
{\t} * @return the number of rows deleted{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the delete{\n}
{\t} */{\n}


{\t}public static int deleteByPrimaryKeySilent(Connection connection, Long {primaryFieldJavaName}) {{{\n}
	{\t}{\t}int numResults = 0;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}numResults = deleteByPrimaryKey(connection, {primaryFieldJavaName});{\n}
	{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
	{\t}{\t}return(numResults);{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Delete a row in the {table.upperName} table by its primary key silently{\n}
{\t} * (i.e. don't throw an exception if it coudn't be deleted).{\n}
{\t} * {\n}
{\t} * @param {primaryFieldJavaName} the primary key to delete{\n}
{\t} * @return the number of rows deleted{\n}
{\t} * {\n}
{\t} * @throws SQLException if there was an error in the delete{\n}
{\t} */{\n}


{\t}public static int deleteByPrimaryKeySilent(Long {primaryFieldJavaName}) {{{\n}
	{\t}{\t}int numResults = 0;{\n}
	{\t}{\t}Connection connection = null;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}numResults = deleteByPrimaryKeySilent(connection, {primaryFieldJavaName});{\n}
	{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}sqlex.printStackTrace();{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}} finally {{{\n}
	{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
	{\t}{\t}}{\n}
	{\t}{\t}return(numResults);{\n}
{\t}}{\n}
{\n}

{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				DELETE ALL STATEMENT
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}

{\t}/**{\n}
{\t} * Delete all of the rows in the table {\n}
{\t} *   '{table.name}'{\n}
{\t} * By executing a SQL delete from statement.  Whilst truncate is faster, if there{\n}
{\t} * Is a foreign key relationship to this table, then the truncate will fail.{\n}
{\t} * {\n}
{\t} * @return The number of rows affected by this statement{\n}
{\t} */{\n}
{\t}public static int deleteAll(Connection connection) throws SQLException {{{\n}
	{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_DELETE_ALL);{\n}

	{\t}{\t}int numResults = preparedStatement.executeUpdate();{\n}
	{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
	{\t}{\t}return(numResults);{\n}
{\t}}{\n}{\n}

{\t}public static int deleteAll() throws SQLException {{{\n}
	{\t}{\t}Connection connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}int value = deleteAll(connection);{\n}
	{\t}{\t}ConnectionManager.closeAll(connection);{\n}
	{\t}{\t}return(value);{\n}
{\t}}{\n}
{\n}

{\t}/**{\n}
{\t} * Delete all of the rows in the table {\n}
{\t} *   '{table.name}'{\n}
{\t} * By executing a SQL truncate command{\n}
{\t} * {\n}
{\t} * @return The number of rows affected by this statement{\n}
{\t} */{\n}
{\t}public static int deleteAllTruncate(Connection connection) throws SQLException {{{\n}
	{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_BUILTIN_DELETE_ALL_TRUNCATE);{\n}

	{\t}{\t}int numResults = preparedStatement.executeUpdate();{\n}
	{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
	{\t}{\t}return(numResults);{\n}
{\t}}{\n}{\n}

{\t}public static int deleteAllTruncate() throws SQLException {{{\n}
	{\t}{\t}Connection connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}int value = deleteAllTruncate(connection);{\n}
	{\t}{\t}ConnectionManager.closeAll(connection);{\n}
	{\t}{\t}return(value);{\n}
{\t}}{\n}
{\n}
{-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
				THE DELETER STATEMENTS
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - --}
{loop table.deleters as deleter}
	{set fn:length[deleter.whereFields] as deleterFieldsLength}

	{\t}public static int {deleter.name}(Connection connection{if fn:>[deleterFieldsLength, 0]}, {endif} 
		{--
		Now for the where fields
	}
	{loop deleter.whereFields as whereField}
		{whereField.javaType} {whereField.javaName}
		{if whereFieldStatus.last}{else},{endif}
	{endloop}

	) throws SQLException {{{\n}

	{\t}{\t}PreparedStatement preparedStatement = connection.prepareStatement(SQL_{deleter.staticName});{\n}

	{loop deleter.whereFields as whereField}
		{\t}{\t}ConnectionManager.set{whereField.upperType}(preparedStatement, {whereFieldStatus.index}, {whereField.javaName});{\n}
	{endloop}
	{\n}

	{\t}{\t}int numResults = preparedStatement.executeUpdate();{\n}

	{\t}{\t}ConnectionManager.closeAll(preparedStatement);{\n}
	{\t}{\t}return(numResults);{\n}
	{\t}}{\n}
{\n}
{endloop}

{loop table.deleters as deleter}
	{\t}public static int {deleter.name}(
	{--
		Now for the where fields
	}
	{loop deleter.whereFields as whereField}
		{whereField.javaType} {whereField.javaName}
		{if whereFieldStatus.last}{else},{endif}
	{endloop}

	) {{{\n}
	{\t}{\t}Connection connection;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}int numRowsDeleted = {deleter.name}(connection{if fn:>[deleterFieldsLength, 0]}, {endif}{loop deleter.whereFields as whereField}
		{whereField.javaName}
		{if whereFieldStatus.last}{else},{endif}
	{endloop});{\n}
	{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
	{\t}{\t}{\t}return(numRowsDeleted);{\n}
	{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}

	{\t}public static int {deleter.name}Silent(
	{--
		Now for the where fields
	}
	{loop deleter.whereFields as whereField}
		{whereField.javaType} {whereField.javaName}
		{if whereFieldStatus.last}{else},{endif}
	{endloop}

	) {{{\n}
	{\t}{\t}Connection connection;{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}connection = ConnectionManager.getConnection();{\n}
	{\t}{\t}{\t}int numRowsDeleted = {deleter.name}(connection{if fn:>[deleterFieldsLength, 0]}, {endif}{loop deleter.whereFields as whereField}
		{whereField.javaName}
		{if whereFieldStatus.last}{else},{endif}
	{endloop});{\n}
	{\t}{\t}{\t}ConnectionManager.closeAll(connection);{\n}
	{\t}{\t}{\t}return(numRowsDeleted);{\n}
	{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}

{\n}

	{\t}public static int {deleter.name}Silent(Connection connection
	{--
		Now for the where fields
	}
	{loop deleter.whereFields as whereField}
		, {whereField.javaType} {whereField.javaName}
	{endloop}

	) {{{\n}
	{\t}{\t}try {{{\n}
	{\t}{\t}{\t}return({deleter.name}(connection{if fn:>[deleterFieldsLength, 0]}, {endif}{loop deleter.whereFields as whereField}
		{whereField.javaName}
		{if whereFieldStatus.last}{else},{endif}
	{endloop}));{\n}
	{\t}{\t}} catch (SQLException sqlex) {{{\n}
	{\t}{\t}{\t}return(-1);{\n}
	{\t}{\t}}{\n}
	{\t}}{\n}

{endloop}


}